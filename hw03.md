Write out variables  x, y and z in binary code<br/> 1) int8_t x = 67;  int8_t y = -7;   int8_t z = y - x;<br/> 2) int8_t x = 0xd3;<br/> 3) uint8_t = 0xd3;<br/> 4) int8_t x = 127;  int8_t y = -7;   int8_t z = y – x;<br/>
5) float x = 1.125;<br/> 6) float x = 23.0;<br/> 7) float x = 0.45;<br/>
上述代码中，哪些出现溢出错误，哪些出现精度误差。<br/>
第2个代码出现溢出错误；第7个有精度误差。<br/><br/><br/>
1)Method of complements<br/>
In mathematics and computing, the method of complements is a technique used to subtract one number from another using only addition of positive numbers. This method was commonly used in mechanical calculators and is still used in modern computers.<br/>
2)Byte<br/>
The byte is a unit of digital information that most commonly consists of eight bits, representing a binary number. Historically, the byte was the number of bits used to encode a single character of text in a computer[1][2] and for this reason it is the smallest addressable unit of memory in many computer architectures.<br/>
3)Integer (computer science)<br/>
In computer science, an integer is a datum of integral data type, a data type that represents some range of mathematical integers. Integral data types may be of different sizes and may or may not be allowed to contain negative values. Integers are commonly represented in a computer as a group of binary digits (bits). The size of the grouping varies so the set of integer sizes available varies between different types of computers. Computer hardware, including virtual machines, nearly always provide a way to represent a processor register or memory address as an integer.<br/>
4)Floating point<br/>
n computing, floating-point arithmetic (FP) is arithmetic using formulaic representation of real numbers as an approximation so as to support a trade-off between range and precision. <br/><br/><br/>





1)请证明：二进制的负数（two‘s complement of X）等于 X 的 ones’
complement ＋ 1（即，X每位求反加1）<br/>
证明：
若二进制的宽度为2^k，则范围是0~2^k-1<br/>设一个数为X，他的负数为Y<br/>根据补码的规则，X+Y=2^k<br/>
所以Y=2^k-1-X+1




1)C程序：int8_t  x = -0x1f;  int y = x;  请用16进制描述变量 x 和 y，并说明 int y = x 的计算过程。<br/><br/> 2)请用数学证明，为什么可以这么计算。<br/><br/>
1）证明：将x转换为十进制，x=-31,将31转换成八位的二进制为11100000，所以-31用补码表示为1110 0001，再将11100001转化为32位的二进制为1111 1111 1111 1111 1111 1111 1110 0001，最后将其转换为十六进制为ffffffe1。
<br/>
2）证明：因为x是负数，所以先求x的绝对值，再求它的补码，然后将二进制转换为十六进制就能得出y。<br/><br/>



1) NaN 是什么？<br/>
IEEE 754 specifies a special value called "Not a Number" (NaN) to be returned as the result of certain "invalid" operations, such as 0/0, ∞×0, or sqrt(−1). In general, NaNs will be propagated i.e. most operations involving a NaN will result in a NaN, although functions that would give some defined result for any given floating-point value will do so for NaNs as well, e.g. NaN ^ 0 = 1. There are two kinds of NaNs: the default quiet NaNs and, optionally, signaling NaNs. A signaling NaN in any arithmetic operation (including numerical comparisons) will cause an "invalid" exception to be signaled.
